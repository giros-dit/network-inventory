# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_ietf_yang_catalog__catalog_modules_module_ietf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/modules/module/ietf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Include this container for the IETF-specific organization metadata.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ietf_wg',)

  _yang_name = 'ietf'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ietf_wg = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ietf-wg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'modules', 'module', 'ietf']

  def _get_ietf_wg(self):
    """
    Getter method for ietf_wg, mapped from YANG variable /catalog/modules/module/ietf/ietf_wg (string)

    YANG Description: Working group that authored the document containing this module.
    """
    return self.__ietf_wg
      
  def _set_ietf_wg(self, v, load=False):
    """
    Setter method for ietf_wg, mapped from YANG variable /catalog/modules/module/ietf/ietf_wg (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ietf_wg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ietf_wg() directly.

    YANG Description: Working group that authored the document containing this module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ietf-wg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ietf_wg must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ietf-wg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__ietf_wg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ietf_wg(self):
    self.__ietf_wg = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ietf-wg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)

  ietf_wg = __builtin__.property(_get_ietf_wg, _set_ietf_wg)


  _pyangbind_elements = OrderedDict([('ietf_wg', ietf_wg), ])


class yc_submodule_yang_catalog__catalog_modules_module_submodule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/modules/module/submodule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry represents one submodule within the
parent module.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revision','__schema',)

  _yang_name = 'submodule'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    self.__schema = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'modules', 'module', 'submodule']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/modules/module/submodule/name (yang:yang-identifier)

    YANG Description: The YANG module or submodule name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/modules/module/submodule/name (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The YANG module or submodule name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)


  def _get_revision(self):
    """
    Getter method for revision, mapped from YANG variable /catalog/modules/module/submodule/revision (union)

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    return self.__revision
      
  def _set_revision(self, v, load=False):
    """
    Setter method for revision, mapped from YANG variable /catalog/modules/module/submodule/revision (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revision() directly.

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revision must be of a type compatible with union""",
          'defined-type': "yang-catalog:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)""",
        })

    self.__revision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revision(self):
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)


  def _get_schema(self):
    """
    Getter method for schema, mapped from YANG variable /catalog/modules/module/submodule/schema (inet:uri)

    YANG Description: Contains a URL that represents the YANG schema
resource for this module or submodule.
This leaf will only be present if there is a URL
available for retrieval of the schema for this entry.
    """
    return self.__schema
      
  def _set_schema(self, v, load=False):
    """
    Setter method for schema, mapped from YANG variable /catalog/modules/module/submodule/schema (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema() directly.

    YANG Description: Contains a URL that represents the YANG schema
resource for this module or submodule.
This leaf will only be present if there is a URL
available for retrieval of the schema for this entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """schema must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)""",
        })

    self.__schema = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_schema(self):
    self.__schema = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revision = __builtin__.property(_get_revision, _set_revision)
  schema = __builtin__.property(_get_schema, _set_schema)


  _pyangbind_elements = OrderedDict([('name', name), ('revision', revision), ('schema', schema), ])


class yc_dependencies_yang_catalog__catalog_modules_module_dependencies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/modules/module/dependencies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry represents one dependency.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revision','__schema',)

  _yang_name = 'dependencies'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    self.__schema = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'modules', 'module', 'dependencies']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/modules/module/dependencies/name (yang:yang-identifier)

    YANG Description: The YANG module or submodule name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/modules/module/dependencies/name (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The YANG module or submodule name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)


  def _get_revision(self):
    """
    Getter method for revision, mapped from YANG variable /catalog/modules/module/dependencies/revision (union)

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    return self.__revision
      
  def _set_revision(self, v, load=False):
    """
    Setter method for revision, mapped from YANG variable /catalog/modules/module/dependencies/revision (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revision() directly.

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revision must be of a type compatible with union""",
          'defined-type': "yang-catalog:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)""",
        })

    self.__revision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revision(self):
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)


  def _get_schema(self):
    """
    Getter method for schema, mapped from YANG variable /catalog/modules/module/dependencies/schema (inet:uri)

    YANG Description: Contains a URL that represents the YANG schema
resource for this module or submodule.
This leaf will only be present if there is a URL
available for retrieval of the schema for this entry.
    """
    return self.__schema
      
  def _set_schema(self, v, load=False):
    """
    Setter method for schema, mapped from YANG variable /catalog/modules/module/dependencies/schema (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema() directly.

    YANG Description: Contains a URL that represents the YANG schema
resource for this module or submodule.
This leaf will only be present if there is a URL
available for retrieval of the schema for this entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """schema must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)""",
        })

    self.__schema = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_schema(self):
    self.__schema = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revision = __builtin__.property(_get_revision, _set_revision)
  schema = __builtin__.property(_get_schema, _set_schema)


  _pyangbind_elements = OrderedDict([('name', name), ('revision', revision), ('schema', schema), ])


class yc_dependents_yang_catalog__catalog_modules_module_dependents(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/modules/module/dependents. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry represents one dependent.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revision','__schema',)

  _yang_name = 'dependents'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    self.__schema = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'modules', 'module', 'dependents']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/modules/module/dependents/name (yang:yang-identifier)

    YANG Description: The YANG module or submodule name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/modules/module/dependents/name (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The YANG module or submodule name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)


  def _get_revision(self):
    """
    Getter method for revision, mapped from YANG variable /catalog/modules/module/dependents/revision (union)

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    return self.__revision
      
  def _set_revision(self, v, load=False):
    """
    Setter method for revision, mapped from YANG variable /catalog/modules/module/dependents/revision (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revision() directly.

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revision must be of a type compatible with union""",
          'defined-type': "yang-catalog:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)""",
        })

    self.__revision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revision(self):
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)


  def _get_schema(self):
    """
    Getter method for schema, mapped from YANG variable /catalog/modules/module/dependents/schema (inet:uri)

    YANG Description: Contains a URL that represents the YANG schema
resource for this module or submodule.
This leaf will only be present if there is a URL
available for retrieval of the schema for this entry.
    """
    return self.__schema
      
  def _set_schema(self, v, load=False):
    """
    Setter method for schema, mapped from YANG variable /catalog/modules/module/dependents/schema (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema() directly.

    YANG Description: Contains a URL that represents the YANG schema
resource for this module or submodule.
This leaf will only be present if there is a URL
available for retrieval of the schema for this entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """schema must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)""",
        })

    self.__schema = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_schema(self):
    self.__schema = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revision = __builtin__.property(_get_revision, _set_revision)
  schema = __builtin__.property(_get_schema, _set_schema)


  _pyangbind_elements = OrderedDict([('name', name), ('revision', revision), ('schema', schema), ])


class yc_deviation_yang_catalog__catalog_modules_module_implementations_implementation_deviation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/modules/module/implementations/implementation/deviation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of YANG deviation module names and revisions
used by this server to modify the conformance of
the module associated with this entry.  Note that
the same module can be used for deviations for
multiple modules, so the same entry MAY appear
within multiple 'module' entries.
The deviation module MUST be present in the 'module'
list, with the same name and revision values.
The 'conformance-type' value will be 'implement' for
the deviation module.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revision',)

  _yang_name = 'deviation'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'modules', 'module', 'implementations', 'implementation', 'deviation']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/modules/module/implementations/implementation/deviation/name (yang:yang-identifier)

    YANG Description: The YANG module or submodule name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/modules/module/implementations/implementation/deviation/name (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The YANG module or submodule name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)


  def _get_revision(self):
    """
    Getter method for revision, mapped from YANG variable /catalog/modules/module/implementations/implementation/deviation/revision (union)

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    return self.__revision
      
  def _set_revision(self, v, load=False):
    """
    Setter method for revision, mapped from YANG variable /catalog/modules/module/implementations/implementation/deviation/revision (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revision() directly.

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revision must be of a type compatible with union""",
          'defined-type': "yang-catalog:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)""",
        })

    self.__revision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revision(self):
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revision = __builtin__.property(_get_revision, _set_revision)


  _pyangbind_elements = OrderedDict([('name', name), ('revision', revision), ])


class yc_implementation_yang_catalog__catalog_modules_module_implementations_implementation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/modules/module/implementations/implementation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of module implementations.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vendor','__platform','__software_version','__software_flavor','__os_version','__feature_set','__os_type','__feature','__deviation','__conformance_type',)

  _yang_name = 'implementation'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__platform = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="platform", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__software_flavor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__os_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__feature_set = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="feature-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__os_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__feature = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']})), is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    self.__deviation = YANGDynClass(base=YANGListType("name revision",yc_deviation_yang_catalog__catalog_modules_module_implementations_implementation_deviation, yang_name="deviation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    self.__conformance_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'implement': {}, 'import': {}},), is_leaf=True, yang_name="conformance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'modules', 'module', 'implementations', 'implementation']

  def _get_vendor(self):
    """
    Getter method for vendor, mapped from YANG variable /catalog/modules/module/implementations/implementation/vendor (string)

    YANG Description: Organization that implements this module.
    """
    return self.__vendor
      
  def _set_vendor(self, v, load=False):
    """
    Setter method for vendor, mapped from YANG variable /catalog/modules/module/implementations/implementation/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Organization that implements this module.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor(self):
    self.__vendor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_platform(self):
    """
    Getter method for platform, mapped from YANG variable /catalog/modules/module/implementations/implementation/platform (string)

    YANG Description: Platform on which this module is implemented.
    """
    return self.__platform
      
  def _set_platform(self, v, load=False):
    """
    Setter method for platform, mapped from YANG variable /catalog/modules/module/implementations/implementation/platform (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_platform is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_platform() directly.

    YANG Description: Platform on which this module is implemented.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="platform", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """platform must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="platform", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__platform = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_platform(self):
    self.__platform = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="platform", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_software_version(self):
    """
    Getter method for software_version, mapped from YANG variable /catalog/modules/module/implementations/implementation/software_version (string)

    YANG Description: Name of the version of software.  With respect to most network device appliances,
this will be the operating system version.  But for other YANG module
implementation, this would be a version of appliance software.  Ultimately,
this should correspond to a version string that will be recognizable by
the consumers of the platform.
    """
    return self.__software_version
      
  def _set_software_version(self, v, load=False):
    """
    Setter method for software_version, mapped from YANG variable /catalog/modules/module/implementations/implementation/software_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: Name of the version of software.  With respect to most network device appliances,
this will be the operating system version.  But for other YANG module
implementation, this would be a version of appliance software.  Ultimately,
this should correspond to a version string that will be recognizable by
the consumers of the platform.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__software_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_version(self):
    self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_software_flavor(self):
    """
    Getter method for software_flavor, mapped from YANG variable /catalog/modules/module/implementations/implementation/software_flavor (string)

    YANG Description: A variation of a specific version where
YANG model support may be different.  Depending on the vendor, this could
be a license, additional software component, or a feature set.
    """
    return self.__software_flavor
      
  def _set_software_flavor(self, v, load=False):
    """
    Setter method for software_flavor, mapped from YANG variable /catalog/modules/module/implementations/implementation/software_flavor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_flavor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_flavor() directly.

    YANG Description: A variation of a specific version where
YANG model support may be different.  Depending on the vendor, this could
be a license, additional software component, or a feature set.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="software-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_flavor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__software_flavor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_flavor(self):
    self.__software_flavor = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_os_version(self):
    """
    Getter method for os_version, mapped from YANG variable /catalog/modules/module/implementations/implementation/os_version (string)

    YANG Description: Version of the operating system using this module.  This is primarily useful if
the software implementing the module is an application that requires a specific
operating system.
    """
    return self.__os_version
      
  def _set_os_version(self, v, load=False):
    """
    Setter method for os_version, mapped from YANG variable /catalog/modules/module/implementations/implementation/os_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_os_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_os_version() directly.

    YANG Description: Version of the operating system using this module.  This is primarily useful if
the software implementing the module is an application that requires a specific
operating system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="os-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """os_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__os_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_os_version(self):
    self.__os_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_feature_set(self):
    """
    Getter method for feature_set, mapped from YANG variable /catalog/modules/module/implementations/implementation/feature_set (string)

    YANG Description: An optional feature of the software that is required in order to implement this
module.  Some form of this must be incorporated in software-version or
software-flavor, but can be broken out here for additional clarity.
    """
    return self.__feature_set
      
  def _set_feature_set(self, v, load=False):
    """
    Setter method for feature_set, mapped from YANG variable /catalog/modules/module/implementations/implementation/feature_set (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature_set is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature_set() directly.

    YANG Description: An optional feature of the software that is required in order to implement this
module.  Some form of this must be incorporated in software-version or
software-flavor, but can be broken out here for additional clarity.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="feature-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature_set must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="feature-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__feature_set = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature_set(self):
    self.__feature_set = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="feature-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_os_type(self):
    """
    Getter method for os_type, mapped from YANG variable /catalog/modules/module/implementations/implementation/os_type (string)

    YANG Description: Type of the operating system using this module.  This is primarily useful if
the software implementing the module is an application that requires a
specific operating system.
    """
    return self.__os_type
      
  def _set_os_type(self, v, load=False):
    """
    Setter method for os_type, mapped from YANG variable /catalog/modules/module/implementations/implementation/os_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_os_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_os_type() directly.

    YANG Description: Type of the operating system using this module.  This is primarily useful if
the software implementing the module is an application that requires a
specific operating system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="os-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """os_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__os_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_os_type(self):
    self.__os_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_feature(self):
    """
    Getter method for feature, mapped from YANG variable /catalog/modules/module/implementations/implementation/feature (yang:yang-identifier)

    YANG Description: List of YANG feature names from this module that are
supported by the server, regardless of whether they are
defined in the module or any included submodule.
    """
    return self.__feature
      
  def _set_feature(self, v, load=False):
    """
    Setter method for feature, mapped from YANG variable /catalog/modules/module/implementations/implementation/feature (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature() directly.

    YANG Description: List of YANG feature names from this module that are
supported by the server, regardless of whether they are
defined in the module or any included submodule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']})), is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']})), is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)""",
        })

    self.__feature = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature(self):
    self.__feature = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']})), is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)


  def _get_deviation(self):
    """
    Getter method for deviation, mapped from YANG variable /catalog/modules/module/implementations/implementation/deviation (list)

    YANG Description: List of YANG deviation module names and revisions
used by this server to modify the conformance of
the module associated with this entry.  Note that
the same module can be used for deviations for
multiple modules, so the same entry MAY appear
within multiple 'module' entries.
The deviation module MUST be present in the 'module'
list, with the same name and revision values.
The 'conformance-type' value will be 'implement' for
the deviation module.
    """
    return self.__deviation
      
  def _set_deviation(self, v, load=False):
    """
    Setter method for deviation, mapped from YANG variable /catalog/modules/module/implementations/implementation/deviation (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_deviation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_deviation() directly.

    YANG Description: List of YANG deviation module names and revisions
used by this server to modify the conformance of
the module associated with this entry.  Note that
the same module can be used for deviations for
multiple modules, so the same entry MAY appear
within multiple 'module' entries.
The deviation module MUST be present in the 'module'
list, with the same name and revision values.
The 'conformance-type' value will be 'implement' for
the deviation module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name revision",yc_deviation_yang_catalog__catalog_modules_module_implementations_implementation_deviation, yang_name="deviation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """deviation must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name revision",yc_deviation_yang_catalog__catalog_modules_module_implementations_implementation_deviation, yang_name="deviation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__deviation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_deviation(self):
    self.__deviation = YANGDynClass(base=YANGListType("name revision",yc_deviation_yang_catalog__catalog_modules_module_implementations_implementation_deviation, yang_name="deviation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)


  def _get_conformance_type(self):
    """
    Getter method for conformance_type, mapped from YANG variable /catalog/modules/module/implementations/implementation/conformance_type (enumeration)

    YANG Description: Indicates the type of conformance the server is claiming
for the YANG module identified by this entry.
    """
    return self.__conformance_type
      
  def _set_conformance_type(self, v, load=False):
    """
    Setter method for conformance_type, mapped from YANG variable /catalog/modules/module/implementations/implementation/conformance_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conformance_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conformance_type() directly.

    YANG Description: Indicates the type of conformance the server is claiming
for the YANG module identified by this entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'implement': {}, 'import': {}},), is_leaf=True, yang_name="conformance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conformance_type must be of a type compatible with enumeration""",
          'defined-type': "yang-catalog:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'implement': {}, 'import': {}},), is_leaf=True, yang_name="conformance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)""",
        })

    self.__conformance_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conformance_type(self):
    self.__conformance_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'implement': {}, 'import': {}},), is_leaf=True, yang_name="conformance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)

  vendor = __builtin__.property(_get_vendor, _set_vendor)
  platform = __builtin__.property(_get_platform, _set_platform)
  software_version = __builtin__.property(_get_software_version, _set_software_version)
  software_flavor = __builtin__.property(_get_software_flavor, _set_software_flavor)
  os_version = __builtin__.property(_get_os_version, _set_os_version)
  feature_set = __builtin__.property(_get_feature_set, _set_feature_set)
  os_type = __builtin__.property(_get_os_type, _set_os_type)
  feature = __builtin__.property(_get_feature, _set_feature)
  deviation = __builtin__.property(_get_deviation, _set_deviation)
  conformance_type = __builtin__.property(_get_conformance_type, _set_conformance_type)


  _pyangbind_elements = OrderedDict([('vendor', vendor), ('platform', platform), ('software_version', software_version), ('software_flavor', software_flavor), ('os_version', os_version), ('feature_set', feature_set), ('os_type', os_type), ('feature', feature), ('deviation', deviation), ('conformance_type', conformance_type), ])


class yc_implementations_yang_catalog__catalog_modules_module_implementations(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/modules/module/implementations. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container holding lists of per-module implementation details.
  """
  __slots__ = ('_path_helper', '_extmethods', '__implementation',)

  _yang_name = 'implementations'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__implementation = YANGDynClass(base=YANGListType("vendor platform software_version software_flavor",yc_implementation_yang_catalog__catalog_modules_module_implementations_implementation, yang_name="implementation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vendor platform software-version software-flavor', extensions=None), is_container='list', yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'modules', 'module', 'implementations']

  def _get_implementation(self):
    """
    Getter method for implementation, mapped from YANG variable /catalog/modules/module/implementations/implementation (list)

    YANG Description: List of module implementations.
    """
    return self.__implementation
      
  def _set_implementation(self, v, load=False):
    """
    Setter method for implementation, mapped from YANG variable /catalog/modules/module/implementations/implementation (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_implementation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_implementation() directly.

    YANG Description: List of module implementations.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vendor platform software_version software_flavor",yc_implementation_yang_catalog__catalog_modules_module_implementations_implementation, yang_name="implementation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vendor platform software-version software-flavor', extensions=None), is_container='list', yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """implementation must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vendor platform software_version software_flavor",yc_implementation_yang_catalog__catalog_modules_module_implementations_implementation, yang_name="implementation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vendor platform software-version software-flavor', extensions=None), is_container='list', yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__implementation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_implementation(self):
    self.__implementation = YANGDynClass(base=YANGListType("vendor platform software_version software_flavor",yc_implementation_yang_catalog__catalog_modules_module_implementations_implementation, yang_name="implementation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vendor platform software-version software-flavor', extensions=None), is_container='list', yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

  implementation = __builtin__.property(_get_implementation, _set_implementation)


  _pyangbind_elements = OrderedDict([('implementation', implementation), ])


class yc_module_yang_catalog__catalog_modules_module(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/modules/module. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry represents one revision of one module
for one organization.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revision','__organization','__ietf','__namespace','__schema','__generated_from','__maturity_level','__document_name','__author_email','__reference','__module_classification','__compilation_status','__compilation_result','__prefix','__yang_version','__description','__contact','__module_type','__belongs_to','__tree_type','__yang_tree','__expires','__expired','__submodule','__dependencies','__dependents','__semantic_version','__derived_semantic_version','__implementations',)

  _yang_name = 'module'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    self.__organization = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="organization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__ietf = YANGDynClass(base=yc_ietf_yang_catalog__catalog_modules_module_ietf, is_container='container', yang_name="ietf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    self.__namespace = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    self.__schema = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    self.__generated_from = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'mib': {}, 'not-applicable': {}, 'native': {}},), default=six.text_type("not-applicable"), is_leaf=True, yang_name="generated-from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    self.__maturity_level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ratified': {}, 'adopted': {}, 'initial': {}, 'not-applicable': {}},), is_leaf=True, yang_name="maturity-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    self.__document_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="document-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__author_email = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': "[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+([.][a-zA-Z0-9-]+)*"}), is_leaf=True, yang_name="author-email", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:email-address', is_config=True)
    self.__reference = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    self.__module_classification = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'network-service': {}, 'network-element': {}, 'unknown': {}, 'not-applicable': {}},), is_leaf=True, yang_name="module-classification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    self.__compilation_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'passed': {}, 'passed-with-warnings': {}, 'failed': {}, 'pending': {}, 'unknown': {}},), is_leaf=True, yang_name="compilation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    self.__compilation_result = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="compilation-result", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    self.__prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__yang_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'1.0': {}, '1.1': {}},), is_leaf=True, yang_name="yang-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__contact = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="contact", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__module_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'module': {}, 'submodule': {}},), is_leaf=True, yang_name="module-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    self.__belongs_to = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="belongs-to", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    self.__tree_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'split': {}, 'nmda-compatible': {}, 'transitional-extra': {}, 'openconfig': {}, 'unclassified': {}, 'not-applicable': {}},), is_leaf=True, yang_name="tree-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    self.__yang_tree = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="yang-tree", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    self.__expires = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="expires", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:date-and-time', is_config=True)
    self.__expired = YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'not-applicable': {}},),], default=YANGBool("false"), is_leaf=True, yang_name="expired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    self.__submodule = YANGDynClass(base=YANGListType("name revision",yc_submodule_yang_catalog__catalog_modules_module_submodule, yang_name="submodule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="submodule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    self.__dependencies = YANGDynClass(base=YANGListType("name",yc_dependencies_yang_catalog__catalog_modules_module_dependencies, yang_name="dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    self.__dependents = YANGDynClass(base=YANGListType("name",yc_dependents_yang_catalog__catalog_modules_module_dependents, yang_name="dependents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="dependents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    self.__semantic_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]+\\.[0-9]+\\.[0-9]+'}), is_leaf=True, yang_name="semantic-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:semver', is_config=True)
    self.__derived_semantic_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]+\\.[0-9]+\\.[0-9]+'}), is_leaf=True, yang_name="derived-semantic-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:semver', is_config=True)
    self.__implementations = YANGDynClass(base=yc_implementations_yang_catalog__catalog_modules_module_implementations, is_container='container', yang_name="implementations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'modules', 'module']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/modules/module/name (yang:yang-identifier)

    YANG Description: The YANG module or submodule name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/modules/module/name (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The YANG module or submodule name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)


  def _get_revision(self):
    """
    Getter method for revision, mapped from YANG variable /catalog/modules/module/revision (union)

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    return self.__revision
      
  def _set_revision(self, v, load=False):
    """
    Setter method for revision, mapped from YANG variable /catalog/modules/module/revision (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revision() directly.

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revision must be of a type compatible with union""",
          'defined-type': "yang-catalog:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)""",
        })

    self.__revision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revision(self):
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)


  def _get_organization(self):
    """
    Getter method for organization, mapped from YANG variable /catalog/modules/module/organization (string)

    YANG Description: This statement defines the party responsible for this
module.  The argument is a string that is used to specify a textual
description of the organization(s) under whose auspices this module
was developed.
    """
    return self.__organization
      
  def _set_organization(self, v, load=False):
    """
    Setter method for organization, mapped from YANG variable /catalog/modules/module/organization (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_organization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_organization() directly.

    YANG Description: This statement defines the party responsible for this
module.  The argument is a string that is used to specify a textual
description of the organization(s) under whose auspices this module
was developed.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="organization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """organization must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="organization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__organization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_organization(self):
    self.__organization = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="organization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_ietf(self):
    """
    Getter method for ietf, mapped from YANG variable /catalog/modules/module/ietf (container)

    YANG Description: Include this container for the IETF-specific organization metadata.
    """
    return self.__ietf
      
  def _set_ietf(self, v, load=False):
    """
    Setter method for ietf, mapped from YANG variable /catalog/modules/module/ietf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ietf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ietf() directly.

    YANG Description: Include this container for the IETF-specific organization metadata.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ietf_yang_catalog__catalog_modules_module_ietf, is_container='container', yang_name="ietf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ietf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ietf_yang_catalog__catalog_modules_module_ietf, is_container='container', yang_name="ietf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)""",
        })

    self.__ietf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ietf(self):
    self.__ietf = YANGDynClass(base=yc_ietf_yang_catalog__catalog_modules_module_ietf, is_container='container', yang_name="ietf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)


  def _get_namespace(self):
    """
    Getter method for namespace, mapped from YANG variable /catalog/modules/module/namespace (inet:uri)

    YANG Description: The XML namespace identifier for this module.
    """
    return self.__namespace
      
  def _set_namespace(self, v, load=False):
    """
    Setter method for namespace, mapped from YANG variable /catalog/modules/module/namespace (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_namespace is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_namespace() directly.

    YANG Description: The XML namespace identifier for this module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """namespace must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)""",
        })

    self.__namespace = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_namespace(self):
    self.__namespace = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)


  def _get_schema(self):
    """
    Getter method for schema, mapped from YANG variable /catalog/modules/module/schema (inet:uri)

    YANG Description: Contains a URL that represents the YANG schema
resource for this module or submodule.
This leaf will only be present if there is a URL
available for retrieval of the schema for this entry.
    """
    return self.__schema
      
  def _set_schema(self, v, load=False):
    """
    Setter method for schema, mapped from YANG variable /catalog/modules/module/schema (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema() directly.

    YANG Description: Contains a URL that represents the YANG schema
resource for this module or submodule.
This leaf will only be present if there is a URL
available for retrieval of the schema for this entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """schema must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)""",
        })

    self.__schema = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_schema(self):
    self.__schema = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="schema", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)


  def _get_generated_from(self):
    """
    Getter method for generated_from, mapped from YANG variable /catalog/modules/module/generated_from (enumeration)

    YANG Description: This statement defines weather the module was generated or not.
Default value is set to not-applicable, which means that module
was created manualy and not generated.
    """
    return self.__generated_from
      
  def _set_generated_from(self, v, load=False):
    """
    Setter method for generated_from, mapped from YANG variable /catalog/modules/module/generated_from (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_generated_from is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_generated_from() directly.

    YANG Description: This statement defines weather the module was generated or not.
Default value is set to not-applicable, which means that module
was created manualy and not generated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'mib': {}, 'not-applicable': {}, 'native': {}},), default=six.text_type("not-applicable"), is_leaf=True, yang_name="generated-from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """generated_from must be of a type compatible with enumeration""",
          'defined-type': "yang-catalog:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'mib': {}, 'not-applicable': {}, 'native': {}},), default=six.text_type("not-applicable"), is_leaf=True, yang_name="generated-from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)""",
        })

    self.__generated_from = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_generated_from(self):
    self.__generated_from = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'mib': {}, 'not-applicable': {}, 'native': {}},), default=six.text_type("not-applicable"), is_leaf=True, yang_name="generated-from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)


  def _get_maturity_level(self):
    """
    Getter method for maturity_level, mapped from YANG variable /catalog/modules/module/maturity_level (enumeration)

    YANG Description: The current maturity of the module with respect to the body that created it.
This allows one to understand where the module is in its overall life cycle.
    """
    return self.__maturity_level
      
  def _set_maturity_level(self, v, load=False):
    """
    Setter method for maturity_level, mapped from YANG variable /catalog/modules/module/maturity_level (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maturity_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maturity_level() directly.

    YANG Description: The current maturity of the module with respect to the body that created it.
This allows one to understand where the module is in its overall life cycle.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ratified': {}, 'adopted': {}, 'initial': {}, 'not-applicable': {}},), is_leaf=True, yang_name="maturity-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maturity_level must be of a type compatible with enumeration""",
          'defined-type': "yang-catalog:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ratified': {}, 'adopted': {}, 'initial': {}, 'not-applicable': {}},), is_leaf=True, yang_name="maturity-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)""",
        })

    self.__maturity_level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maturity_level(self):
    self.__maturity_level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ratified': {}, 'adopted': {}, 'initial': {}, 'not-applicable': {}},), is_leaf=True, yang_name="maturity-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)


  def _get_document_name(self):
    """
    Getter method for document_name, mapped from YANG variable /catalog/modules/module/document_name (string)

    YANG Description: The name of the document from which the module was extracted or taken;
or that provides additional context about the module.
    """
    return self.__document_name
      
  def _set_document_name(self, v, load=False):
    """
    Setter method for document_name, mapped from YANG variable /catalog/modules/module/document_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_document_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_document_name() directly.

    YANG Description: The name of the document from which the module was extracted or taken;
or that provides additional context about the module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="document-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """document_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="document-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__document_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_document_name(self):
    self.__document_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="document-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_author_email(self):
    """
    Getter method for author_email, mapped from YANG variable /catalog/modules/module/author_email (yc:email-address)

    YANG Description: Contact email of the author who is responsible for this module.
    """
    return self.__author_email
      
  def _set_author_email(self, v, load=False):
    """
    Setter method for author_email, mapped from YANG variable /catalog/modules/module/author_email (yc:email-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_author_email is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_author_email() directly.

    YANG Description: Contact email of the author who is responsible for this module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': "[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+([.][a-zA-Z0-9-]+)*"}), is_leaf=True, yang_name="author-email", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:email-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """author_email must be of a type compatible with yc:email-address""",
          'defined-type': "yc:email-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': "[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+([.][a-zA-Z0-9-]+)*"}), is_leaf=True, yang_name="author-email", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:email-address', is_config=True)""",
        })

    self.__author_email = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_author_email(self):
    self.__author_email = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': "[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+([.][a-zA-Z0-9-]+)*"}), is_leaf=True, yang_name="author-email", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:email-address', is_config=True)


  def _get_reference(self):
    """
    Getter method for reference, mapped from YANG variable /catalog/modules/module/reference (inet:uri)

    YANG Description: A string that is used to specify a textual cross-reference to an external document, either
another module that defines related management information, or a document that provides
additional information relevant to this definition.
    """
    return self.__reference
      
  def _set_reference(self, v, load=False):
    """
    Setter method for reference, mapped from YANG variable /catalog/modules/module/reference (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reference() directly.

    YANG Description: A string that is used to specify a textual cross-reference to an external document, either
another module that defines related management information, or a document that provides
additional information relevant to this definition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reference must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)""",
        })

    self.__reference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reference(self):
    self.__reference = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)


  def _get_module_classification(self):
    """
    Getter method for module_classification, mapped from YANG variable /catalog/modules/module/module_classification (enumeration)

    YANG Description: The high-level classification of the given YANG module.
    """
    return self.__module_classification
      
  def _set_module_classification(self, v, load=False):
    """
    Setter method for module_classification, mapped from YANG variable /catalog/modules/module/module_classification (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_module_classification is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_module_classification() directly.

    YANG Description: The high-level classification of the given YANG module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'network-service': {}, 'network-element': {}, 'unknown': {}, 'not-applicable': {}},), is_leaf=True, yang_name="module-classification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """module_classification must be of a type compatible with enumeration""",
          'defined-type': "yang-catalog:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'network-service': {}, 'network-element': {}, 'unknown': {}, 'not-applicable': {}},), is_leaf=True, yang_name="module-classification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)""",
        })

    self.__module_classification = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_module_classification(self):
    self.__module_classification = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'network-service': {}, 'network-element': {}, 'unknown': {}, 'not-applicable': {}},), is_leaf=True, yang_name="module-classification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)


  def _get_compilation_status(self):
    """
    Getter method for compilation_status, mapped from YANG variable /catalog/modules/module/compilation_status (enumeration)

    YANG Description: Status of the module, whether it was possible to compile this YANG module or
there are still some errors/warnings.
    """
    return self.__compilation_status
      
  def _set_compilation_status(self, v, load=False):
    """
    Setter method for compilation_status, mapped from YANG variable /catalog/modules/module/compilation_status (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compilation_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compilation_status() directly.

    YANG Description: Status of the module, whether it was possible to compile this YANG module or
there are still some errors/warnings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'passed': {}, 'passed-with-warnings': {}, 'failed': {}, 'pending': {}, 'unknown': {}},), is_leaf=True, yang_name="compilation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compilation_status must be of a type compatible with enumeration""",
          'defined-type': "yang-catalog:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'passed': {}, 'passed-with-warnings': {}, 'failed': {}, 'pending': {}, 'unknown': {}},), is_leaf=True, yang_name="compilation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)""",
        })

    self.__compilation_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compilation_status(self):
    self.__compilation_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'passed': {}, 'passed-with-warnings': {}, 'failed': {}, 'pending': {}, 'unknown': {}},), is_leaf=True, yang_name="compilation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)


  def _get_compilation_result(self):
    """
    Getter method for compilation_result, mapped from YANG variable /catalog/modules/module/compilation_result (inet:uri)

    YANG Description: Link to the result of the compilation explaining specifically what error or
warning occurred.  This is not existing if compilation status is PASSED.
    """
    return self.__compilation_result
      
  def _set_compilation_result(self, v, load=False):
    """
    Setter method for compilation_result, mapped from YANG variable /catalog/modules/module/compilation_result (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compilation_result is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compilation_result() directly.

    YANG Description: Link to the result of the compilation explaining specifically what error or
warning occurred.  This is not existing if compilation status is PASSED.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="compilation-result", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compilation_result must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="compilation-result", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)""",
        })

    self.__compilation_result = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compilation_result(self):
    self.__compilation_result = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="compilation-result", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)


  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /catalog/modules/module/prefix (string)

    YANG Description: Statement of yang that is used to define the prefix associated with
the module and its namespace. The prefix statement's argument is
the prefix string that is used as a prefix to access a module. The
prefix string MAY be used to refer to definitions contained in the
module, e.g., if:ifName.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /catalog/modules/module/prefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Statement of yang that is used to define the prefix associated with
the module and its namespace. The prefix statement's argument is
the prefix string that is used as a prefix to access a module. The
prefix string MAY be used to refer to definitions contained in the
module, e.g., if:ifName.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_yang_version(self):
    """
    Getter method for yang_version, mapped from YANG variable /catalog/modules/module/yang_version (enumeration)

    YANG Description: The optional yang-version statement specifies which version of the
YANG language was used in developing the module.
    """
    return self.__yang_version
      
  def _set_yang_version(self, v, load=False):
    """
    Setter method for yang_version, mapped from YANG variable /catalog/modules/module/yang_version (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_yang_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_yang_version() directly.

    YANG Description: The optional yang-version statement specifies which version of the
YANG language was used in developing the module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'1.0': {}, '1.1': {}},), is_leaf=True, yang_name="yang-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """yang_version must be of a type compatible with enumeration""",
          'defined-type': "yang-catalog:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'1.0': {}, '1.1': {}},), is_leaf=True, yang_name="yang-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)""",
        })

    self.__yang_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_yang_version(self):
    self.__yang_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'1.0': {}, '1.1': {}},), is_leaf=True, yang_name="yang-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /catalog/modules/module/description (string)

    YANG Description: This statement takes as an argument a string that
contains a human-readable textual description of this definition.
The text is provided in a language (or languages) chosen by the
module developer; for the sake of interoperability, it is RECOMMENDED
to choose a language that is widely understood among the community of
network administrators who will use the module.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /catalog/modules/module/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This statement takes as an argument a string that
contains a human-readable textual description of this definition.
The text is provided in a language (or languages) chosen by the
module developer; for the sake of interoperability, it is RECOMMENDED
to choose a language that is widely understood among the community of
network administrators who will use the module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_contact(self):
    """
    Getter method for contact, mapped from YANG variable /catalog/modules/module/contact (string)

    YANG Description: This statement provides contact information for the module.
The argument is a string that is used to specify contact information
for the person or persons to whom technical queries concerning this
module should be sent, such as their name, postal address, telephone
number, and electronic mail address.
    """
    return self.__contact
      
  def _set_contact(self, v, load=False):
    """
    Setter method for contact, mapped from YANG variable /catalog/modules/module/contact (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_contact is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_contact() directly.

    YANG Description: This statement provides contact information for the module.
The argument is a string that is used to specify contact information
for the person or persons to whom technical queries concerning this
module should be sent, such as their name, postal address, telephone
number, and electronic mail address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="contact", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """contact must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="contact", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__contact = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_contact(self):
    self.__contact = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="contact", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_module_type(self):
    """
    Getter method for module_type, mapped from YANG variable /catalog/modules/module/module_type (enumeration)

    YANG Description: Whether a file contains a YANG module or sub-module.
    """
    return self.__module_type
      
  def _set_module_type(self, v, load=False):
    """
    Setter method for module_type, mapped from YANG variable /catalog/modules/module/module_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_module_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_module_type() directly.

    YANG Description: Whether a file contains a YANG module or sub-module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'module': {}, 'submodule': {}},), is_leaf=True, yang_name="module-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """module_type must be of a type compatible with enumeration""",
          'defined-type': "yang-catalog:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'module': {}, 'submodule': {}},), is_leaf=True, yang_name="module-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)""",
        })

    self.__module_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_module_type(self):
    self.__module_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'module': {}, 'submodule': {}},), is_leaf=True, yang_name="module-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)


  def _get_belongs_to(self):
    """
    Getter method for belongs_to, mapped from YANG variable /catalog/modules/module/belongs_to (yang:yang-identifier)

    YANG Description: Name of the module that includes this submodule.
    """
    return self.__belongs_to
      
  def _set_belongs_to(self, v, load=False):
    """
    Setter method for belongs_to, mapped from YANG variable /catalog/modules/module/belongs_to (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_belongs_to is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_belongs_to() directly.

    YANG Description: Name of the module that includes this submodule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="belongs-to", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """belongs_to must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="belongs-to", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)""",
        })

    self.__belongs_to = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_belongs_to(self):
    self.__belongs_to = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="belongs-to", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)


  def _get_tree_type(self):
    """
    Getter method for tree_type, mapped from YANG variable /catalog/modules/module/tree_type (enumeration)

    YANG Description: The type of data element tree used by the module as it relates to the
Network Management Datastores Architecture.
    """
    return self.__tree_type
      
  def _set_tree_type(self, v, load=False):
    """
    Setter method for tree_type, mapped from YANG variable /catalog/modules/module/tree_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tree_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tree_type() directly.

    YANG Description: The type of data element tree used by the module as it relates to the
Network Management Datastores Architecture.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'split': {}, 'nmda-compatible': {}, 'transitional-extra': {}, 'openconfig': {}, 'unclassified': {}, 'not-applicable': {}},), is_leaf=True, yang_name="tree-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tree_type must be of a type compatible with enumeration""",
          'defined-type': "yang-catalog:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'split': {}, 'nmda-compatible': {}, 'transitional-extra': {}, 'openconfig': {}, 'unclassified': {}, 'not-applicable': {}},), is_leaf=True, yang_name="tree-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)""",
        })

    self.__tree_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tree_type(self):
    self.__tree_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'split': {}, 'nmda-compatible': {}, 'transitional-extra': {}, 'openconfig': {}, 'unclassified': {}, 'not-applicable': {}},), is_leaf=True, yang_name="tree-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)


  def _get_yang_tree(self):
    """
    Getter method for yang_tree, mapped from YANG variable /catalog/modules/module/yang_tree (inet:uri)

    YANG Description: This leaf provides a URI that points to the ASCII tree format of the module in
draft-ietf-netmod-yang-tree-diagrams format.
    """
    return self.__yang_tree
      
  def _set_yang_tree(self, v, load=False):
    """
    Setter method for yang_tree, mapped from YANG variable /catalog/modules/module/yang_tree (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_yang_tree is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_yang_tree() directly.

    YANG Description: This leaf provides a URI that points to the ASCII tree format of the module in
draft-ietf-netmod-yang-tree-diagrams format.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="yang-tree", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """yang_tree must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="yang-tree", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)""",
        })

    self.__yang_tree = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_yang_tree(self):
    self.__yang_tree = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="yang-tree", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='inet:uri', is_config=True)


  def _get_expires(self):
    """
    Getter method for expires, mapped from YANG variable /catalog/modules/module/expires (yang:date-and-time)

    YANG Description: Date and time of when this module expires (if it expires).  This will typically be used for
modules that have not been fully ratified.
    """
    return self.__expires
      
  def _set_expires(self, v, load=False):
    """
    Setter method for expires, mapped from YANG variable /catalog/modules/module/expires (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_expires is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_expires() directly.

    YANG Description: Date and time of when this module expires (if it expires).  This will typically be used for
modules that have not been fully ratified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="expires", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """expires must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="expires", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__expires = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_expires(self):
    self.__expires = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="expires", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:date-and-time', is_config=True)


  def _get_expired(self):
    """
    Getter method for expired, mapped from YANG variable /catalog/modules/module/expired (union)

    YANG Description: Whether or not this module has expired.  If the current date is beyond the expires date, then expired
should be true.
    """
    return self.__expired
      
  def _set_expired(self, v, load=False):
    """
    Setter method for expired, mapped from YANG variable /catalog/modules/module/expired (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_expired is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_expired() directly.

    YANG Description: Whether or not this module has expired.  If the current date is beyond the expires date, then expired
should be true.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[YANGBool,RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'not-applicable': {}},),], default=YANGBool("false"), is_leaf=True, yang_name="expired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """expired must be of a type compatible with union""",
          'defined-type': "yang-catalog:union",
          'generated-type': """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'not-applicable': {}},),], default=YANGBool("false"), is_leaf=True, yang_name="expired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)""",
        })

    self.__expired = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_expired(self):
    self.__expired = YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'not-applicable': {}},),], default=YANGBool("false"), is_leaf=True, yang_name="expired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)


  def _get_submodule(self):
    """
    Getter method for submodule, mapped from YANG variable /catalog/modules/module/submodule (list)

    YANG Description: Each entry represents one submodule within the
parent module.
    """
    return self.__submodule
      
  def _set_submodule(self, v, load=False):
    """
    Setter method for submodule, mapped from YANG variable /catalog/modules/module/submodule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_submodule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_submodule() directly.

    YANG Description: Each entry represents one submodule within the
parent module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name revision",yc_submodule_yang_catalog__catalog_modules_module_submodule, yang_name="submodule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="submodule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """submodule must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name revision",yc_submodule_yang_catalog__catalog_modules_module_submodule, yang_name="submodule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="submodule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__submodule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_submodule(self):
    self.__submodule = YANGDynClass(base=YANGListType("name revision",yc_submodule_yang_catalog__catalog_modules_module_submodule, yang_name="submodule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="submodule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)


  def _get_dependencies(self):
    """
    Getter method for dependencies, mapped from YANG variable /catalog/modules/module/dependencies (list)

    YANG Description: Each entry represents one dependency.
    """
    return self.__dependencies
      
  def _set_dependencies(self, v, load=False):
    """
    Setter method for dependencies, mapped from YANG variable /catalog/modules/module/dependencies (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dependencies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dependencies() directly.

    YANG Description: Each entry represents one dependency.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_dependencies_yang_catalog__catalog_modules_module_dependencies, yang_name="dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dependencies must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_dependencies_yang_catalog__catalog_modules_module_dependencies, yang_name="dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__dependencies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dependencies(self):
    self.__dependencies = YANGDynClass(base=YANGListType("name",yc_dependencies_yang_catalog__catalog_modules_module_dependencies, yang_name="dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)


  def _get_dependents(self):
    """
    Getter method for dependents, mapped from YANG variable /catalog/modules/module/dependents (list)

    YANG Description: Each entry represents one dependent.
    """
    return self.__dependents
      
  def _set_dependents(self, v, load=False):
    """
    Setter method for dependents, mapped from YANG variable /catalog/modules/module/dependents (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dependents is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dependents() directly.

    YANG Description: Each entry represents one dependent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_dependents_yang_catalog__catalog_modules_module_dependents, yang_name="dependents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="dependents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dependents must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_dependents_yang_catalog__catalog_modules_module_dependents, yang_name="dependents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="dependents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__dependents = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dependents(self):
    self.__dependents = YANGDynClass(base=YANGListType("name",yc_dependents_yang_catalog__catalog_modules_module_dependents, yang_name="dependents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="dependents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)


  def _get_semantic_version(self):
    """
    Getter method for semantic_version, mapped from YANG variable /catalog/modules/module/semantic_version (yc:semver)

    YANG Description: The formal semantic version of a module as provided by the module
itself.  If the module does not provide a semantic version, this leaf
will not be specified.
    """
    return self.__semantic_version
      
  def _set_semantic_version(self, v, load=False):
    """
    Setter method for semantic_version, mapped from YANG variable /catalog/modules/module/semantic_version (yc:semver)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_semantic_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_semantic_version() directly.

    YANG Description: The formal semantic version of a module as provided by the module
itself.  If the module does not provide a semantic version, this leaf
will not be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]+\\.[0-9]+\\.[0-9]+'}), is_leaf=True, yang_name="semantic-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:semver', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """semantic_version must be of a type compatible with yc:semver""",
          'defined-type': "yc:semver",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]+\\.[0-9]+\\.[0-9]+'}), is_leaf=True, yang_name="semantic-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:semver', is_config=True)""",
        })

    self.__semantic_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_semantic_version(self):
    self.__semantic_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]+\\.[0-9]+\\.[0-9]+'}), is_leaf=True, yang_name="semantic-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:semver', is_config=True)


  def _get_derived_semantic_version(self):
    """
    Getter method for derived_semantic_version, mapped from YANG variable /catalog/modules/module/derived_semantic_version (yc:semver)

    YANG Description: The semantic version of a module as compared to other revisions of
the same module.  This value is computed algorithmically by ordering
all revisions of a given module and comparing them to look for backwards
incompatible changes.
    """
    return self.__derived_semantic_version
      
  def _set_derived_semantic_version(self, v, load=False):
    """
    Setter method for derived_semantic_version, mapped from YANG variable /catalog/modules/module/derived_semantic_version (yc:semver)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_derived_semantic_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_derived_semantic_version() directly.

    YANG Description: The semantic version of a module as compared to other revisions of
the same module.  This value is computed algorithmically by ordering
all revisions of a given module and comparing them to look for backwards
incompatible changes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]+\\.[0-9]+\\.[0-9]+'}), is_leaf=True, yang_name="derived-semantic-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:semver', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """derived_semantic_version must be of a type compatible with yc:semver""",
          'defined-type': "yc:semver",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]+\\.[0-9]+\\.[0-9]+'}), is_leaf=True, yang_name="derived-semantic-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:semver', is_config=True)""",
        })

    self.__derived_semantic_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_derived_semantic_version(self):
    self.__derived_semantic_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9]+\\.[0-9]+\\.[0-9]+'}), is_leaf=True, yang_name="derived-semantic-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yc:semver', is_config=True)


  def _get_implementations(self):
    """
    Getter method for implementations, mapped from YANG variable /catalog/modules/module/implementations (container)

    YANG Description: Container holding lists of per-module implementation details.
    """
    return self.__implementations
      
  def _set_implementations(self, v, load=False):
    """
    Setter method for implementations, mapped from YANG variable /catalog/modules/module/implementations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_implementations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_implementations() directly.

    YANG Description: Container holding lists of per-module implementation details.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_implementations_yang_catalog__catalog_modules_module_implementations, is_container='container', yang_name="implementations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """implementations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_implementations_yang_catalog__catalog_modules_module_implementations, is_container='container', yang_name="implementations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)""",
        })

    self.__implementations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_implementations(self):
    self.__implementations = YANGDynClass(base=yc_implementations_yang_catalog__catalog_modules_module_implementations, is_container='container', yang_name="implementations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revision = __builtin__.property(_get_revision, _set_revision)
  organization = __builtin__.property(_get_organization, _set_organization)
  ietf = __builtin__.property(_get_ietf, _set_ietf)
  namespace = __builtin__.property(_get_namespace, _set_namespace)
  schema = __builtin__.property(_get_schema, _set_schema)
  generated_from = __builtin__.property(_get_generated_from, _set_generated_from)
  maturity_level = __builtin__.property(_get_maturity_level, _set_maturity_level)
  document_name = __builtin__.property(_get_document_name, _set_document_name)
  author_email = __builtin__.property(_get_author_email, _set_author_email)
  reference = __builtin__.property(_get_reference, _set_reference)
  module_classification = __builtin__.property(_get_module_classification, _set_module_classification)
  compilation_status = __builtin__.property(_get_compilation_status, _set_compilation_status)
  compilation_result = __builtin__.property(_get_compilation_result, _set_compilation_result)
  prefix = __builtin__.property(_get_prefix, _set_prefix)
  yang_version = __builtin__.property(_get_yang_version, _set_yang_version)
  description = __builtin__.property(_get_description, _set_description)
  contact = __builtin__.property(_get_contact, _set_contact)
  module_type = __builtin__.property(_get_module_type, _set_module_type)
  belongs_to = __builtin__.property(_get_belongs_to, _set_belongs_to)
  tree_type = __builtin__.property(_get_tree_type, _set_tree_type)
  yang_tree = __builtin__.property(_get_yang_tree, _set_yang_tree)
  expires = __builtin__.property(_get_expires, _set_expires)
  expired = __builtin__.property(_get_expired, _set_expired)
  submodule = __builtin__.property(_get_submodule, _set_submodule)
  dependencies = __builtin__.property(_get_dependencies, _set_dependencies)
  dependents = __builtin__.property(_get_dependents, _set_dependents)
  semantic_version = __builtin__.property(_get_semantic_version, _set_semantic_version)
  derived_semantic_version = __builtin__.property(_get_derived_semantic_version, _set_derived_semantic_version)
  implementations = __builtin__.property(_get_implementations, _set_implementations)


  _pyangbind_elements = OrderedDict([('name', name), ('revision', revision), ('organization', organization), ('ietf', ietf), ('namespace', namespace), ('schema', schema), ('generated_from', generated_from), ('maturity_level', maturity_level), ('document_name', document_name), ('author_email', author_email), ('reference', reference), ('module_classification', module_classification), ('compilation_status', compilation_status), ('compilation_result', compilation_result), ('prefix', prefix), ('yang_version', yang_version), ('description', description), ('contact', contact), ('module_type', module_type), ('belongs_to', belongs_to), ('tree_type', tree_type), ('yang_tree', yang_tree), ('expires', expires), ('expired', expired), ('submodule', submodule), ('dependencies', dependencies), ('dependents', dependents), ('semantic_version', semantic_version), ('derived_semantic_version', derived_semantic_version), ('implementations', implementations), ])


class yc_modules_yang_catalog__catalog_modules(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/modules. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container holding the list of modules
  """
  __slots__ = ('_path_helper', '_extmethods', '__module',)

  _yang_name = 'modules'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__module = YANGDynClass(base=YANGListType("name revision organization",yc_module_yang_catalog__catalog_modules_module, yang_name="module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision organization', extensions=None), is_container='list', yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'modules']

  def _get_module(self):
    """
    Getter method for module, mapped from YANG variable /catalog/modules/module (list)

    YANG Description: Each entry represents one revision of one module
for one organization.
    """
    return self.__module
      
  def _set_module(self, v, load=False):
    """
    Setter method for module, mapped from YANG variable /catalog/modules/module (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_module is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_module() directly.

    YANG Description: Each entry represents one revision of one module
for one organization.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name revision organization",yc_module_yang_catalog__catalog_modules_module, yang_name="module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision organization', extensions=None), is_container='list', yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """module must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name revision organization",yc_module_yang_catalog__catalog_modules_module, yang_name="module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision organization', extensions=None), is_container='list', yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__module = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_module(self):
    self.__module = YANGDynClass(base=YANGListType("name revision organization",yc_module_yang_catalog__catalog_modules_module, yang_name="module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision organization', extensions=None), is_container='list', yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

  module = __builtin__.property(_get_module, _set_module)


  _pyangbind_elements = OrderedDict([('module', module), ])


class yc_protocol_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_protocols_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms/platform/software-versions/software-version/software-flavors/software-flavor/protocols/protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: YANG-based protocol that is used on the device.  New identities
are expected to be added to address other YANG-based protocols.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__protocol_version','__capabilities',)

  _yang_name = 'protocol'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'netconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'yc:netconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'restconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'yc:restconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}},), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='identityref', is_config=True)
    self.__protocol_version = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__capabilities = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms', 'platform', 'software-versions', 'software-version', 'software-flavors', 'software-flavor', 'protocols', 'protocol']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/protocols/protocol/name (identityref)

    YANG Description: Identity of the YANG-based protocol that is supported.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/protocols/protocol/name (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Identity of the YANG-based protocol that is supported.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'netconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'yc:netconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'restconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'yc:restconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}},), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with identityref""",
          'defined-type': "yang-catalog:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'netconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'yc:netconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'restconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'yc:restconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}},), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='identityref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'netconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'yc:netconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'restconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}, 'yc:restconf': {'@module': 'yang-catalog', '@namespace': 'urn:ietf:params:xml:ns:yang:yang-catalog'}},), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='identityref', is_config=True)


  def _get_protocol_version(self):
    """
    Getter method for protocol_version, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/protocols/protocol/protocol_version (string)

    YANG Description: Version of the specific protocol.
    """
    return self.__protocol_version
      
  def _set_protocol_version(self, v, load=False):
    """
    Setter method for protocol_version, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/protocols/protocol/protocol_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_version() directly.

    YANG Description: Version of the specific protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__protocol_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_version(self):
    self.__protocol_version = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="protocol-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_capabilities(self):
    """
    Getter method for capabilities, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/protocols/protocol/capabilities (string)

    YANG Description: Listed name of capabilities that are
supported by the specific device.
    """
    return self.__capabilities
      
  def _set_capabilities(self, v, load=False):
    """
    Setter method for capabilities, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/protocols/protocol/capabilities (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capabilities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capabilities() directly.

    YANG Description: Listed name of capabilities that are
supported by the specific device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capabilities must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__capabilities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capabilities(self):
    self.__capabilities = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  protocol_version = __builtin__.property(_get_protocol_version, _set_protocol_version)
  capabilities = __builtin__.property(_get_capabilities, _set_capabilities)


  _pyangbind_elements = OrderedDict([('name', name), ('protocol_version', protocol_version), ('capabilities', capabilities), ])


class yc_protocols_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms/platform/software-versions/software-version/software-flavors/software-flavor/protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the protocols
  """
  __slots__ = ('_path_helper', '_extmethods', '__protocol',)

  _yang_name = 'protocols'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol = YANGDynClass(base=YANGListType("name",yc_protocol_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_protocols_protocol, yang_name="protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms', 'platform', 'software-versions', 'software-version', 'software-flavors', 'software-flavor', 'protocols']

  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/protocols/protocol (list)

    YANG Description: YANG-based protocol that is used on the device.  New identities
are expected to be added to address other YANG-based protocols.
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/protocols/protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: YANG-based protocol that is used on the device.  New identities
are expected to be added to address other YANG-based protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_protocol_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_protocols_protocol, yang_name="protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_protocol_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_protocols_protocol, yang_name="protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=YANGListType("name",yc_protocol_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_protocols_protocol, yang_name="protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

  protocol = __builtin__.property(_get_protocol, _set_protocol)


  _pyangbind_elements = OrderedDict([('protocol', protocol), ])


class yc_deviation_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules_module_deviation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms/platform/software-versions/software-version/software-flavors/software-flavor/modules/module/deviation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of YANG deviation module names and revisions
used by this server to modify the conformance of
the module associated with this entry.  Note that
the same module can be used for deviations for
multiple modules, so the same entry MAY appear
within multiple 'module' entries.
The deviation module MUST be present in the 'module'
list, with the same name and revision values.
The 'conformance-type' value will be 'implement' for
the deviation module.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revision',)

  _yang_name = 'deviation'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms', 'platform', 'software-versions', 'software-version', 'software-flavors', 'software-flavor', 'modules', 'module', 'deviation']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/deviation/name (yang:yang-identifier)

    YANG Description: The YANG module or submodule name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/deviation/name (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The YANG module or submodule name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)


  def _get_revision(self):
    """
    Getter method for revision, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/deviation/revision (union)

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    return self.__revision
      
  def _set_revision(self, v, load=False):
    """
    Setter method for revision, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/deviation/revision (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revision() directly.

    YANG Description: The YANG module or submodule revision date.
A zero-length string is used if no revision statement
is present in the YANG module or submodule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revision must be of a type compatible with union""",
          'defined-type': "yang-catalog:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)""",
        })

    self.__revision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revision(self):
    self.__revision = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0']}),], is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='union', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revision = __builtin__.property(_get_revision, _set_revision)


  _pyangbind_elements = OrderedDict([('name', name), ('revision', revision), ])


class yc_module_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules_module(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms/platform/software-versions/software-version/software-flavors/software-flavor/modules/module. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of references to YANG modules under specific vendor, platform, software-version,
software-flavor.  Using these references, the complete set of metadata can be
retrieved for each module.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revision','__organization','__os_version','__feature_set','__os_type','__feature','__deviation','__conformance_type',)

  _yang_name = 'module'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)
    self.__revision = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)
    self.__organization = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="organization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)
    self.__os_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__feature_set = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="feature-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__os_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__feature = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']})), is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    self.__deviation = YANGDynClass(base=YANGListType("name revision",yc_deviation_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules_module_deviation, yang_name="deviation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    self.__conformance_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'implement': {}, 'import': {}},), is_leaf=True, yang_name="conformance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms', 'platform', 'software-versions', 'software-version', 'software-flavors', 'software-flavor', 'modules', 'module']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/name (leafref)

    YANG Description: Reference to a name of the module that is contained in specific vendor, platform,
software-version, software-flavor.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to a name of the module that is contained in specific vendor, platform,
software-version, software-flavor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)


  def _get_revision(self):
    """
    Getter method for revision, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/revision (leafref)

    YANG Description: Reference to a revision of the module that is contained in specific vendor,
platform, software-version, software-flavor.
    """
    return self.__revision
      
  def _set_revision(self, v, load=False):
    """
    Setter method for revision, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/revision (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revision() directly.

    YANG Description: Reference to a revision of the module that is contained in specific vendor,
platform, software-version, software-flavor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revision must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)""",
        })

    self.__revision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revision(self):
    self.__revision = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="revision", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)


  def _get_organization(self):
    """
    Getter method for organization, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/organization (leafref)

    YANG Description: Reference to the authoring organization of the module for the implemented
 module.
    """
    return self.__organization
      
  def _set_organization(self, v, load=False):
    """
    Setter method for organization, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/organization (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_organization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_organization() directly.

    YANG Description: Reference to the authoring organization of the module for the implemented
 module.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="organization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """organization must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="organization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)""",
        })

    self.__organization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_organization(self):
    self.__organization = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="organization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='leafref', is_config=True)


  def _get_os_version(self):
    """
    Getter method for os_version, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/os_version (string)

    YANG Description: Version of the operating system using this module.  This is primarily useful if
the software implementing the module is an application that requires a specific
operating system.
    """
    return self.__os_version
      
  def _set_os_version(self, v, load=False):
    """
    Setter method for os_version, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/os_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_os_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_os_version() directly.

    YANG Description: Version of the operating system using this module.  This is primarily useful if
the software implementing the module is an application that requires a specific
operating system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="os-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """os_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__os_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_os_version(self):
    self.__os_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_feature_set(self):
    """
    Getter method for feature_set, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/feature_set (string)

    YANG Description: An optional feature of the software that is required in order to implement this
module.  Some form of this must be incorporated in software-version or
software-flavor, but can be broken out here for additional clarity.
    """
    return self.__feature_set
      
  def _set_feature_set(self, v, load=False):
    """
    Setter method for feature_set, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/feature_set (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature_set is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature_set() directly.

    YANG Description: An optional feature of the software that is required in order to implement this
module.  Some form of this must be incorporated in software-version or
software-flavor, but can be broken out here for additional clarity.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="feature-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature_set must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="feature-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__feature_set = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature_set(self):
    self.__feature_set = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="feature-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_os_type(self):
    """
    Getter method for os_type, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/os_type (string)

    YANG Description: Type of the operating system using this module.  This is primarily useful if
the software implementing the module is an application that requires a
specific operating system.
    """
    return self.__os_type
      
  def _set_os_type(self, v, load=False):
    """
    Setter method for os_type, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/os_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_os_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_os_type() directly.

    YANG Description: Type of the operating system using this module.  This is primarily useful if
the software implementing the module is an application that requires a
specific operating system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="os-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """os_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__os_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_os_type(self):
    self.__os_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="os-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_feature(self):
    """
    Getter method for feature, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/feature (yang:yang-identifier)

    YANG Description: List of YANG feature names from this module that are
supported by the server, regardless of whether they are
defined in the module or any included submodule.
    """
    return self.__feature
      
  def _set_feature(self, v, load=False):
    """
    Setter method for feature, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/feature (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature() directly.

    YANG Description: List of YANG feature names from this module that are
supported by the server, regardless of whether they are
defined in the module or any included submodule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']})), is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']})), is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)""",
        })

    self.__feature = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature(self):
    self.__feature = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']})), is_leaf=False, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='yang:yang-identifier', is_config=True)


  def _get_deviation(self):
    """
    Getter method for deviation, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/deviation (list)

    YANG Description: List of YANG deviation module names and revisions
used by this server to modify the conformance of
the module associated with this entry.  Note that
the same module can be used for deviations for
multiple modules, so the same entry MAY appear
within multiple 'module' entries.
The deviation module MUST be present in the 'module'
list, with the same name and revision values.
The 'conformance-type' value will be 'implement' for
the deviation module.
    """
    return self.__deviation
      
  def _set_deviation(self, v, load=False):
    """
    Setter method for deviation, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/deviation (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_deviation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_deviation() directly.

    YANG Description: List of YANG deviation module names and revisions
used by this server to modify the conformance of
the module associated with this entry.  Note that
the same module can be used for deviations for
multiple modules, so the same entry MAY appear
within multiple 'module' entries.
The deviation module MUST be present in the 'module'
list, with the same name and revision values.
The 'conformance-type' value will be 'implement' for
the deviation module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name revision",yc_deviation_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules_module_deviation, yang_name="deviation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """deviation must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name revision",yc_deviation_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules_module_deviation, yang_name="deviation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__deviation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_deviation(self):
    self.__deviation = YANGDynClass(base=YANGListType("name revision",yc_deviation_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules_module_deviation, yang_name="deviation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision', extensions=None), is_container='list', yang_name="deviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)


  def _get_conformance_type(self):
    """
    Getter method for conformance_type, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/conformance_type (enumeration)

    YANG Description: Indicates the type of conformance the server is claiming
for the YANG module identified by this entry.
    """
    return self.__conformance_type
      
  def _set_conformance_type(self, v, load=False):
    """
    Setter method for conformance_type, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module/conformance_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conformance_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conformance_type() directly.

    YANG Description: Indicates the type of conformance the server is claiming
for the YANG module identified by this entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'implement': {}, 'import': {}},), is_leaf=True, yang_name="conformance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conformance_type must be of a type compatible with enumeration""",
          'defined-type': "yang-catalog:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'implement': {}, 'import': {}},), is_leaf=True, yang_name="conformance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)""",
        })

    self.__conformance_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conformance_type(self):
    self.__conformance_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'implement': {}, 'import': {}},), is_leaf=True, yang_name="conformance-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='enumeration', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revision = __builtin__.property(_get_revision, _set_revision)
  organization = __builtin__.property(_get_organization, _set_organization)
  os_version = __builtin__.property(_get_os_version, _set_os_version)
  feature_set = __builtin__.property(_get_feature_set, _set_feature_set)
  os_type = __builtin__.property(_get_os_type, _set_os_type)
  feature = __builtin__.property(_get_feature, _set_feature)
  deviation = __builtin__.property(_get_deviation, _set_deviation)
  conformance_type = __builtin__.property(_get_conformance_type, _set_conformance_type)


  _pyangbind_elements = OrderedDict([('name', name), ('revision', revision), ('organization', organization), ('os_version', os_version), ('feature_set', feature_set), ('os_type', os_type), ('feature', feature), ('deviation', deviation), ('conformance_type', conformance_type), ])


class yc_modules_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms/platform/software-versions/software-version/software-flavors/software-flavor/modules. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container holding list of modules.
  """
  __slots__ = ('_path_helper', '_extmethods', '__module',)

  _yang_name = 'modules'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__module = YANGDynClass(base=YANGListType("name revision organization",yc_module_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules_module, yang_name="module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision organization', extensions=None), is_container='list', yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms', 'platform', 'software-versions', 'software-version', 'software-flavors', 'software-flavor', 'modules']

  def _get_module(self):
    """
    Getter method for module, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module (list)

    YANG Description: List of references to YANG modules under specific vendor, platform, software-version,
software-flavor.  Using these references, the complete set of metadata can be
retrieved for each module.
    """
    return self.__module
      
  def _set_module(self, v, load=False):
    """
    Setter method for module, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules/module (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_module is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_module() directly.

    YANG Description: List of references to YANG modules under specific vendor, platform, software-version,
software-flavor.  Using these references, the complete set of metadata can be
retrieved for each module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name revision organization",yc_module_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules_module, yang_name="module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision organization', extensions=None), is_container='list', yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """module must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name revision organization",yc_module_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules_module, yang_name="module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision organization', extensions=None), is_container='list', yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__module = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_module(self):
    self.__module = YANGDynClass(base=YANGListType("name revision organization",yc_module_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules_module, yang_name="module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name revision organization', extensions=None), is_container='list', yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

  module = __builtin__.property(_get_module, _set_module)


  _pyangbind_elements = OrderedDict([('module', module), ])


class yc_software_flavor_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms/platform/software-versions/software-version/software-flavors/software-flavor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of software flavors under specific vendor, platform, software-version.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__protocols','__modules',)

  _yang_name = 'software-flavor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__protocols = YANGDynClass(base=yc_protocols_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    self.__modules = YANGDynClass(base=yc_modules_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules, is_container='container', yang_name="modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms', 'platform', 'software-versions', 'software-version', 'software-flavors', 'software-flavor']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/name (string)

    YANG Description: A variation of a specific version where
YANG model support may be different.  Depending on the vendor, this could
be a license, additional software component, or a feature set.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: A variation of a specific version where
YANG model support may be different.  Depending on the vendor, this could
be a license, additional software component, or a feature set.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_protocols(self):
    """
    Getter method for protocols, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/protocols (container)

    YANG Description: List of the protocols
    """
    return self.__protocols
      
  def _set_protocols(self, v, load=False):
    """
    Setter method for protocols, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocols() directly.

    YANG Description: List of the protocols
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_protocols_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_protocols_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)""",
        })

    self.__protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocols(self):
    self.__protocols = YANGDynClass(base=yc_protocols_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_protocols, is_container='container', yang_name="protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)


  def _get_modules(self):
    """
    Getter method for modules, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules (container)

    YANG Description: Container holding list of modules.
    """
    return self.__modules
      
  def _set_modules(self, v, load=False):
    """
    Setter method for modules, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor/modules (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modules() directly.

    YANG Description: Container holding list of modules.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_modules_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules, is_container='container', yang_name="modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modules must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_modules_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules, is_container='container', yang_name="modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)""",
        })

    self.__modules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modules(self):
    self.__modules = YANGDynClass(base=yc_modules_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor_modules, is_container='container', yang_name="modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  protocols = __builtin__.property(_get_protocols, _set_protocols)
  modules = __builtin__.property(_get_modules, _set_modules)


  _pyangbind_elements = OrderedDict([('name', name), ('protocols', protocols), ('modules', modules), ])


class yc_software_flavors_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms/platform/software-versions/software-version/software-flavors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container holding list of software flavors.
  """
  __slots__ = ('_path_helper', '_extmethods', '__software_flavor',)

  _yang_name = 'software-flavors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__software_flavor = YANGDynClass(base=YANGListType("name",yc_software_flavor_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor, yang_name="software-flavor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="software-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms', 'platform', 'software-versions', 'software-version', 'software-flavors']

  def _get_software_flavor(self):
    """
    Getter method for software_flavor, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor (list)

    YANG Description: List of software flavors under specific vendor, platform, software-version.
    """
    return self.__software_flavor
      
  def _set_software_flavor(self, v, load=False):
    """
    Setter method for software_flavor, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors/software_flavor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_flavor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_flavor() directly.

    YANG Description: List of software flavors under specific vendor, platform, software-version.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_software_flavor_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor, yang_name="software-flavor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="software-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_flavor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_software_flavor_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor, yang_name="software-flavor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="software-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__software_flavor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_flavor(self):
    self.__software_flavor = YANGDynClass(base=YANGListType("name",yc_software_flavor_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors_software_flavor, yang_name="software-flavor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="software-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

  software_flavor = __builtin__.property(_get_software_flavor, _set_software_flavor)


  _pyangbind_elements = OrderedDict([('software_flavor', software_flavor), ])


class yc_software_version_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms/platform/software-versions/software-version. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of version of software versions under specific vendor, platform.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__software_flavors',)

  _yang_name = 'software-version'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__software_flavors = YANGDynClass(base=yc_software_flavors_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors, is_container='container', yang_name="software-flavors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms', 'platform', 'software-versions', 'software-version']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/name (string)

    YANG Description: Name of the version of software.  With respect to most network device appliances,
this will be the operating system version.  But for other YANG module
implementation, this would be a version of appliance software.  Ultimately,
this should correspond to a version string that will be recognizable by
the consumers of the platform.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the version of software.  With respect to most network device appliances,
this will be the operating system version.  But for other YANG module
implementation, this would be a version of appliance software.  Ultimately,
this should correspond to a version string that will be recognizable by
the consumers of the platform.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_software_flavors(self):
    """
    Getter method for software_flavors, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors (container)

    YANG Description: Container holding list of software flavors.
    """
    return self.__software_flavors
      
  def _set_software_flavors(self, v, load=False):
    """
    Setter method for software_flavors, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version/software_flavors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_flavors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_flavors() directly.

    YANG Description: Container holding list of software flavors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_software_flavors_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors, is_container='container', yang_name="software-flavors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_flavors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_software_flavors_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors, is_container='container', yang_name="software-flavors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)""",
        })

    self.__software_flavors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_flavors(self):
    self.__software_flavors = YANGDynClass(base=yc_software_flavors_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version_software_flavors, is_container='container', yang_name="software-flavors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  software_flavors = __builtin__.property(_get_software_flavors, _set_software_flavors)


  _pyangbind_elements = OrderedDict([('name', name), ('software_flavors', software_flavors), ])


class yc_software_versions_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms/platform/software-versions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container holding list of versions of software versions.
  """
  __slots__ = ('_path_helper', '_extmethods', '__software_version',)

  _yang_name = 'software-versions'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__software_version = YANGDynClass(base=YANGListType("name",yc_software_version_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version, yang_name="software-version", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms', 'platform', 'software-versions']

  def _get_software_version(self):
    """
    Getter method for software_version, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version (list)

    YANG Description: List of version of software versions under specific vendor, platform.
    """
    return self.__software_version
      
  def _set_software_version(self, v, load=False):
    """
    Setter method for software_version, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions/software_version (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: List of version of software versions under specific vendor, platform.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_software_version_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version, yang_name="software-version", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_version must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_software_version_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version, yang_name="software-version", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__software_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_version(self):
    self.__software_version = YANGDynClass(base=YANGListType("name",yc_software_version_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions_software_version, yang_name="software-version", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

  software_version = __builtin__.property(_get_software_version, _set_software_version)


  _pyangbind_elements = OrderedDict([('software_version', software_version), ])


class yc_platform_yang_catalog__catalog_vendors_vendor_platforms_platform(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms/platform. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of platforms under specific vendor
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__software_versions',)

  _yang_name = 'platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__software_versions = YANGDynClass(base=yc_software_versions_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions, is_container='container', yang_name="software-versions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms', 'platform']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/name (string)

    YANG Description: Name of the platform
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the platform
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_software_versions(self):
    """
    Getter method for software_versions, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions (container)

    YANG Description: Container holding list of versions of software versions.
    """
    return self.__software_versions
      
  def _set_software_versions(self, v, load=False):
    """
    Setter method for software_versions, mapped from YANG variable /catalog/vendors/vendor/platforms/platform/software_versions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_versions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_versions() directly.

    YANG Description: Container holding list of versions of software versions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_software_versions_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions, is_container='container', yang_name="software-versions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_versions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_software_versions_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions, is_container='container', yang_name="software-versions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)""",
        })

    self.__software_versions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_versions(self):
    self.__software_versions = YANGDynClass(base=yc_software_versions_yang_catalog__catalog_vendors_vendor_platforms_platform_software_versions, is_container='container', yang_name="software-versions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  software_versions = __builtin__.property(_get_software_versions, _set_software_versions)


  _pyangbind_elements = OrderedDict([('name', name), ('software_versions', software_versions), ])


class yc_platforms_yang_catalog__catalog_vendors_vendor_platforms(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor/platforms. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container holding list of platforms.
  """
  __slots__ = ('_path_helper', '_extmethods', '__platform',)

  _yang_name = 'platforms'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__platform = YANGDynClass(base=YANGListType("name",yc_platform_yang_catalog__catalog_vendors_vendor_platforms_platform, yang_name="platform", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="platform", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor', 'platforms']

  def _get_platform(self):
    """
    Getter method for platform, mapped from YANG variable /catalog/vendors/vendor/platforms/platform (list)

    YANG Description: List of platforms under specific vendor
    """
    return self.__platform
      
  def _set_platform(self, v, load=False):
    """
    Setter method for platform, mapped from YANG variable /catalog/vendors/vendor/platforms/platform (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_platform is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_platform() directly.

    YANG Description: List of platforms under specific vendor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_platform_yang_catalog__catalog_vendors_vendor_platforms_platform, yang_name="platform", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="platform", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """platform must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_platform_yang_catalog__catalog_vendors_vendor_platforms_platform, yang_name="platform", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="platform", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__platform = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_platform(self):
    self.__platform = YANGDynClass(base=YANGListType("name",yc_platform_yang_catalog__catalog_vendors_vendor_platforms_platform, yang_name="platform", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="platform", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

  platform = __builtin__.property(_get_platform, _set_platform)


  _pyangbind_elements = OrderedDict([('platform', platform), ])


class yc_vendor_yang_catalog__catalog_vendors_vendor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors/vendor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of organizations publishing YANG modules.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__platforms',)

  _yang_name = 'vendor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    self.__platforms = YANGDynClass(base=yc_platforms_yang_catalog__catalog_vendors_vendor_platforms, is_container='container', yang_name="platforms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors', 'vendor']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /catalog/vendors/vendor/name (string)

    YANG Description: Name of the maintaining organization -- the name should be
supplied in the official format used by the organization.
Standards Body examples:
  IETF, IEEE, MEF, ONF, etc.
Commercial entity examples:
  AT&T, Facebook, <Vendor>
Name of industry forum examples:
OpenConfig, OpenDaylight, ON.Lab
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /catalog/vendors/vendor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the maintaining organization -- the name should be
supplied in the official format used by the organization.
Standards Body examples:
  IETF, IEEE, MEF, ONF, etc.
Commercial entity examples:
  AT&T, Facebook, <Vendor>
Name of industry forum examples:
OpenConfig, OpenDaylight, ON.Lab
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='string', is_config=True)


  def _get_platforms(self):
    """
    Getter method for platforms, mapped from YANG variable /catalog/vendors/vendor/platforms (container)

    YANG Description: Container holding list of platforms.
    """
    return self.__platforms
      
  def _set_platforms(self, v, load=False):
    """
    Setter method for platforms, mapped from YANG variable /catalog/vendors/vendor/platforms (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_platforms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_platforms() directly.

    YANG Description: Container holding list of platforms.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_platforms_yang_catalog__catalog_vendors_vendor_platforms, is_container='container', yang_name="platforms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """platforms must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_platforms_yang_catalog__catalog_vendors_vendor_platforms, is_container='container', yang_name="platforms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)""",
        })

    self.__platforms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_platforms(self):
    self.__platforms = YANGDynClass(base=yc_platforms_yang_catalog__catalog_vendors_vendor_platforms, is_container='container', yang_name="platforms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  platforms = __builtin__.property(_get_platforms, _set_platforms)


  _pyangbind_elements = OrderedDict([('name', name), ('platforms', platforms), ])


class yc_vendors_yang_catalog__catalog_vendors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog/vendors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container holding lists of organizations that publish YANG modules.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vendor',)

  _yang_name = 'vendors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vendor = YANGDynClass(base=YANGListType("name",yc_vendor_yang_catalog__catalog_vendors_vendor, yang_name="vendor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog', 'vendors']

  def _get_vendor(self):
    """
    Getter method for vendor, mapped from YANG variable /catalog/vendors/vendor (list)

    YANG Description: List of organizations publishing YANG modules.
    """
    return self.__vendor
      
  def _set_vendor(self, v, load=False):
    """
    Setter method for vendor, mapped from YANG variable /catalog/vendors/vendor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: List of organizations publishing YANG modules.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_vendor_yang_catalog__catalog_vendors_vendor, yang_name="vendor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_vendor_yang_catalog__catalog_vendors_vendor, yang_name="vendor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)""",
        })

    self.__vendor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor(self):
    self.__vendor = YANGDynClass(base=YANGListType("name",yc_vendor_yang_catalog__catalog_vendors_vendor, yang_name="vendor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='list', is_config=True)

  vendor = __builtin__.property(_get_vendor, _set_vendor)


  _pyangbind_elements = OrderedDict([('vendor', vendor), ])


class yc_catalog_yang_catalog__catalog(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /catalog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Root container of yang-catalog holding two main branches -
modules and vendors. The modules sub-tree contains all the modules in
the catalog and all of their metadata with their implementations.
The vendor sub-tree holds modules for specific vendors, platforms,
software-versions, and software-flavors. It contains reference to a
name and revision of the module in order to reference the module's full
set of metadata.
  """
  __slots__ = ('_path_helper', '_extmethods', '__modules','__vendors',)

  _yang_name = 'catalog'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__modules = YANGDynClass(base=yc_modules_yang_catalog__catalog_modules, is_container='container', yang_name="modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    self.__vendors = YANGDynClass(base=yc_vendors_yang_catalog__catalog_vendors, is_container='container', yang_name="vendors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['catalog']

  def _get_modules(self):
    """
    Getter method for modules, mapped from YANG variable /catalog/modules (container)

    YANG Description: Container holding the list of modules
    """
    return self.__modules
      
  def _set_modules(self, v, load=False):
    """
    Setter method for modules, mapped from YANG variable /catalog/modules (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modules() directly.

    YANG Description: Container holding the list of modules
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_modules_yang_catalog__catalog_modules, is_container='container', yang_name="modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modules must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_modules_yang_catalog__catalog_modules, is_container='container', yang_name="modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)""",
        })

    self.__modules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modules(self):
    self.__modules = YANGDynClass(base=yc_modules_yang_catalog__catalog_modules, is_container='container', yang_name="modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)


  def _get_vendors(self):
    """
    Getter method for vendors, mapped from YANG variable /catalog/vendors (container)

    YANG Description: Container holding lists of organizations that publish YANG modules.
    """
    return self.__vendors
      
  def _set_vendors(self, v, load=False):
    """
    Setter method for vendors, mapped from YANG variable /catalog/vendors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendors() directly.

    YANG Description: Container holding lists of organizations that publish YANG modules.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vendors_yang_catalog__catalog_vendors, is_container='container', yang_name="vendors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vendors_yang_catalog__catalog_vendors, is_container='container', yang_name="vendors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)""",
        })

    self.__vendors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendors(self):
    self.__vendors = YANGDynClass(base=yc_vendors_yang_catalog__catalog_vendors, is_container='container', yang_name="vendors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

  modules = __builtin__.property(_get_modules, _set_modules)
  vendors = __builtin__.property(_get_vendors, _set_vendors)


  _pyangbind_elements = OrderedDict([('modules', modules), ('vendors', vendors), ])


class yang_catalog(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module yang-catalog - based on the path /yang-catalog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains metadata pertinent to each YANG module, as
well as a list of vendor implementations for each module.  The
structure is laid out in such a way as to make it possible to
locate metadata and vendor implementation on a per-module basis
as well as obtain a list of available modules for a given
vendor's platform and specific software release.
  """
  __slots__ = ('_path_helper', '_extmethods', '__catalog',)

  _yang_name = 'yang-catalog'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__catalog = YANGDynClass(base=yc_catalog_yang_catalog__catalog, is_container='container', yang_name="catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_catalog(self):
    """
    Getter method for catalog, mapped from YANG variable /catalog (container)

    YANG Description: Root container of yang-catalog holding two main branches -
modules and vendors. The modules sub-tree contains all the modules in
the catalog and all of their metadata with their implementations.
The vendor sub-tree holds modules for specific vendors, platforms,
software-versions, and software-flavors. It contains reference to a
name and revision of the module in order to reference the module's full
set of metadata.
    """
    return self.__catalog
      
  def _set_catalog(self, v, load=False):
    """
    Setter method for catalog, mapped from YANG variable /catalog (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_catalog is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_catalog() directly.

    YANG Description: Root container of yang-catalog holding two main branches -
modules and vendors. The modules sub-tree contains all the modules in
the catalog and all of their metadata with their implementations.
The vendor sub-tree holds modules for specific vendors, platforms,
software-versions, and software-flavors. It contains reference to a
name and revision of the module in order to reference the module's full
set of metadata.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_catalog_yang_catalog__catalog, is_container='container', yang_name="catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """catalog must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_catalog_yang_catalog__catalog, is_container='container', yang_name="catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)""",
        })

    self.__catalog = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_catalog(self):
    self.__catalog = YANGDynClass(base=yc_catalog_yang_catalog__catalog, is_container='container', yang_name="catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:yang-catalog', defining_module='yang-catalog', yang_type='container', is_config=True)

  catalog = __builtin__.property(_get_catalog, _set_catalog)


  _pyangbind_elements = OrderedDict([('catalog', catalog), ])


